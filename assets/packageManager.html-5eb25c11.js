import{_ as p,p as d,q as s,s as n,R as e,t as i,Z as o,n as l}from"./framework-1749bed7.js";const c="/guyu.inn/assets/pnpm-e0f620e0.png",r="/guyu.inn/assets/pnpm1-af6d2c71.png",t="/guyu.inn/assets/memorepo-2f5c72bd.webp",m={},u=o('<h3 id="硬链接和软链接" tabindex="-1"><a class="header-anchor" href="#硬链接和软链接" aria-hidden="true">#</a> 硬链接和软链接</h3><blockquote><p><strong>硬连接</strong></p><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><p><strong>软连接</strong></p><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p></blockquote><p>简单来说 硬链接就是&quot;深拷贝了一个文件&quot; 软链接就是快捷方式</p><h1 id="yarn-pnpm-npm-区别" tabindex="-1"><a class="header-anchor" href="#yarn-pnpm-npm-区别" aria-hidden="true">#</a> yarn / pnpm / npm 区别</h1><p>包管理器深入的话其实和操作系统关系很大的</p><p>这里还没学过操作系统，所以也无法特别深入</p><h3 id="yarn" tabindex="-1"><a class="header-anchor" href="#yarn" aria-hidden="true">#</a> yarn</h3><p>扁平化 减少node_modules的嵌套</p><p>利用yarn.lock 锁定依赖版本 为什么？</p><p>因为一个包可能有多个版本，提升铺平只能提升一个，后面如果遇见相同包的不同版本还是要嵌套</p><ul><li>扁平化方案的问题 幽灵依赖</li></ul><p>就是没有在 dependencies中声明依赖 但在代码里可以import 其实就是所有依赖都铺平了，那依赖的依赖就可以找到</p><p>问题就是 因为不是显示依赖 如果别的包不依赖这个包了， 那我们就跑不了了</p><ul><li>yarn lock作用</li></ul><p>先明确，package.json 中的版本号 为 <code>[major].[minor].[patch]</code>, 主要/次要/补丁，然后前面会有一些符号，如<code>^, ~, &gt;, &lt;,-, x</code>等，这些符号可控制版本，即package.json 中的版本号 为一个 <code>版本区间</code>，yarn.lock中的version字段是唯一版本号</p><blockquote><p>^ 表示大于等于当前版本，并允许<code>minor</code>级别的递增。</p><p>~ 表示大于等于当前版本，并允许<code>patch</code>级别的递增。</p><p>&gt; / &gt;= 表示大于/大于等于当前版本即可。</p><p>&lt; / &lt;= 表示小于/小于等于当前版本即可。</p><p>- 表示两个版本范围之间，并包括两个版本。（闭区间）</p><p>x 可以在<code>major</code>, <code>minor</code>, <code>patch</code>任意位置，表示任何数字。</p><p>|| 表示或，任意版本或版本范围满足其一。</p></blockquote><p>具体作用</p><blockquote><p>用于锁定项目中每个依赖项的确切版本，以便在不同的开发环境中始终使用相同的依赖项版本，从而避免在生产环境部署时出现依赖项版本不一致的问题。</p><p>当您运行 <code>yarn install</code> 安装项目依赖项时，Yarn 会检查 <code>yarn.lock</code> 文件并下载列出的确切版本的依赖项。如果 <code>yarn.lock</code> 文件不存在，则 Yarn 将根据 <code>package.json</code> 文件中指定的版本范围下载符合条件的最新版本的依赖项，并将这些确切的版本记录在新生成的 <code>yarn.lock</code> 文件中。</p><p>因此，<code>yarn.lock</code> 文件确保项目依赖项的版本一致性，避免了在不同的环境中安装不同版本的依赖项可能出现的问题。</p></blockquote><p>Npm3 采用扁平依赖 npm7采用 lock文件</p><h3 id="pnpm优势" tabindex="-1"><a class="header-anchor" href="#pnpm优势" aria-hidden="true">#</a> pnpm优势</h3><ol><li>速度快</li><li>高效利用磁盘空间</li></ol><p>pnpm 内部使用<code>基于内容寻址</code>的文件系统来存储磁盘上所有的文件，这个文件系统出色的地方在于:</p>',22),b=n("code",null,"hardlink",-1),v={href:"https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fitech%2Farchive%2F2009%2F04%2F10%2F1433052.html",target:"_blank",rel:"noopener noreferrer"},h=n("li",null,[e("即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。举个例子，比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 "),n("code",null,"hardlink"),e("，仅仅写入那"),n("code",null,"一个新增的文件"),e("。")],-1),g=o(`<ol start="3"><li><p>支持monorepo monorepo简单的说就是把所有代码放到一个仓库中</p></li><li><p>更安全</p></li></ol><h3 id="被诟病的npm" tabindex="-1"><a class="header-anchor" href="#被诟病的npm" aria-hidden="true">#</a> 被诟病的npm</h3><p>npm1,npm2中的node_modules结构是这样的， 可以想象如果出现循环依赖或者共享依赖会发生什么，这也是一个经典梗图，node_modules比黑洞质量还大(指嵌套的深度)</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>node_modules
└─ foo
   ├─ index.js
   ├─ package.json
   └─ node_modules
      └─ bar
         ├─ index.js
         └─ package.json

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后yarn出现，再到npm3(现在已经有8了)，就采取扁平化管理了，但扁平化管理依然有问题</p><ul><li>依赖结构的<strong>不确定性</strong>。</li><li>扁平化算法本身的<strong>复杂性</strong>很高，耗时较长。</li><li>项目中仍然可以<strong>非法访问</strong>没有声明过依赖的包</li></ul><p>看这个不确定性，简单来说就是如下情况</p><p>假如现在项目依赖两个包 foo 和 bar，这两个包的依赖又是这样的:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>foo -&gt; babel@1.0
bar -&gt; babel@2.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>那么扁平化后是以下哪种？</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 第一种情况
node_modules
└─ foo
└─ bar
		└─babel@2.0
└─ babel@1.0

// 第二种情况
node_modules
└─ foo
		└─ babel@1.0
└─ bar
└─babel@2.0

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>答案是: 都有可能。取决于 foo 和 bar 在 <code>package.json</code>中的位置，如果 foo 声明在前面，那么就是前面的结构，否则是后面的结构。</p><p>这就是为什么会产生依赖结构的<code>不确定</code>问题，也是 <code>lock 文件</code>诞生的原因，无论是<code>package-lock.json</code>(npm 5.x才出现)还是<code>yarn.lock</code>，都是为了保证 install 之后都产生确定的<code>node_modules</code>结构。</p><p>那用pnpm安装依赖后是什么情形呢</p><p><img src="`+c+'" alt="pnpm"></p><p>看这个目录，你打开vite也好，ahooks也好，这些仅仅只是一个<code>软链接</code>，都是没有node_modules目录的，那么这些包的依赖在哪儿?</p><p>打开.pnpm目录 随便打开一个包就会发现其所依赖的node_modules 这个.pnpm 就是从全局store 硬链接过来的，可以叫他虚拟store</p><p><img src="'+r+'" alt="Snipaste_2022-05-27_18-11-57"></p><p>到统一目录下后 包和包之间的依赖关系就是软链接</p><blockquote><p>将<code>包本身</code>和<code>依赖</code>放在同一个<code>node_module</code>下面，与原生 Node 完全兼容，又能将 package 与相关的依赖很好地组织到一起，设计十分精妙。</p><p>现在我们回过头来看，根目录下的 node_modules 下面不再是眼花缭乱的依赖，而是跟 package.json 声明的依赖基本保持一致。即使 pnpm 内部会有一些包会设置依赖提升，会被提升到根目录 node_modules 当中，但整体上，根目录的<code>node_modules</code>比以前还是清晰和规范了许多。</p></blockquote><p><code>pnpm</code> 也解决了幽灵依赖的问题</p><h3 id="延伸-执行-npm-run-后发生什么" tabindex="-1"><a class="header-anchor" href="#延伸-执行-npm-run-后发生什么" aria-hidden="true">#</a> 延伸: 执行 npm run 后发生什么？</h3><ol><li><p>运行 npm run xxx的时候，npm 会先在当前目录的 node_modules/.bin 查找要执行的程序，如果找到则运行；</p></li><li><p>没有找到则从全局的 node_modules/.bin 中查找，npm i -g xxx就是安装到到全局目录；</p></li><li><p>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。</p></li></ol><p>就比如一个Vite 项目 我们执行 pnpm dev，看package.json， 实际上是执行了 “vite命令”，但如果我们直接执行vite是会报错的，因为操作系统中并没有这条指令。</p><p>所以，真正运行的，其实是node_modules/bin/vite 这个脚本文件，这个脚本文件在我们pnpm install安装依赖的时候就会被自动生成</p><p>bin 目录，这个目录不是任何一个 npm 包。目录下的文件，表示这是一个个软链接，打开文件可以看到文件顶部写着 <code>#!/bin/sh</code> ，表示这是一个脚本。</p><p>.bin 目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？它又是怎么知道这条软连接是执行哪里的呢？</p><p>bin字段不是在自己项目的package.json文件里面，而是在库的源代码中的package.json里面，用于在安装时创建软链指向bin中的地址</p><p>所以在 npm install 时，npm 读到该配置后，就将该文件软链接到 ./node_modules/.bin 目录下，而 npm 还会自动把node_modules/.bin加入$PATH，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了。</p><p>假如我们在安装包时，使用 <code>npm install -g xxx</code> 来安装，那么会将其中的 bin 文件加入到全局，比如 create-react-app 和 vue-cli ，在全局安装后，就可以直接使用如 vue-cli projectName 这样的命令来创建项目了</p><p>也就是说，npm i 的时候，npm 就帮我们把这种软连接配置好了，其实这种软连接相当于一种映射，执行npm run xxx 的时候，就会到 node_modules/bin中找对应的映射文件，然后再找到相应的js文件来执行。</p><h3 id="yalc" tabindex="-1"><a class="header-anchor" href="#yalc" aria-hidden="true">#</a> yalc</h3><p>yalc是一个用于本地软件包开发和管理的工具。它可以让你在本地创建软件包并将其链接到其他本地项目中，而不必在NPM注册表上发布它们。这使得在本地进行开发和测试变得更加容易和灵活，而且不需要在不同项目之间频繁地进行版本控制。</p><p><code>yalc publish</code> 对应的包先发布。然后 yalc link 链接</p><h3 id="monorepo" tabindex="-1"><a class="header-anchor" href="#monorepo" aria-hidden="true">#</a> monorepo</h3><p><img src="'+t+`" alt=""></p><blockquote><p>概念上很好理解，就是把<strong>多个项目</strong>放在<strong>一个仓库</strong>里面，相对立的是传统的 MultiRepo 模式，即每个项目对应一个单独的仓库来分散管理。</p></blockquote><p>一般 Monorepo 的目录如下所示，在 packages 存放多个子项目，并且每个子项目都有自己的<code>package.json</code>:</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>├── packages
<span class="token operator">|</span>   ├── pkg1
<span class="token operator">|</span>   <span class="token operator">|</span>   ├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
<span class="token operator">|</span>   ├── pkg2
<span class="token operator">|</span>   <span class="token operator">|</span>   ├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意MultiRepo的三个痛点:</p><ol><li>代码复用</li></ol><p>加入我有多个项目，然后这些项目的工具函数啊，共同组件逻辑啊我们都把抽出封装成一个包发布了，然后有时候想改一行代码。我们需要修改包，然后重新发布，然后再到各个项目去更新相关的包</p><ol start="2"><li>版本管理</li></ol><p>其实和上面说的很像，就是一个包更新后，所有依赖这个包的项目如果没即使更新依赖，可能就会出现各种不兼容的报错</p><ol start="3"><li>项目基建</li></ol><blockquote><p>由于在 MultiRepo 当中，各个项目的工作流是割裂的，因此每个项目需要单独配置开发环境、配置 CI 流程、配置部署发布流程等等，甚至每个项目都有自己单独的一套脚手架工具。</p><p>其实，很容易发现这些项目里的很多基建的逻辑都是重复的，如果是 10 个项目，就需要维护 10 份基建的流程，逻辑重复不说，各个项目间存在构建、部署和发布的规范不能统一的情况，这样维护起来就更加麻烦了。</p></blockquote><h2 id="monorepo-的收益" tabindex="-1"><a class="header-anchor" href="#monorepo-的收益" aria-hidden="true">#</a> Monorepo 的收益</h2><blockquote><p>说清楚 <code>MultiRepo</code> 的痛点之后，相信你也大概能理解为什么要诞生<code>Monorepo</code>这个技术了。现在就来细致地分析一下<code>Monorepo</code>到底给现代的前端工程带来了哪些收益。</p><p>首先是<strong>工作流的一致性</strong>，由于所有的项目放在一个仓库当中，复用起来非常方便，如果有依赖的代码变动，那么用到这个依赖的项目当中会立马感知到。并且所有的项目都是使用最新的代码，不会产生其它项目版本更新不及时的情况。</p><p>其次是<strong>项目基建成本的降低</strong>，所有项目复用一套标准的工具和规范，无需切换开发环境，如果有新的项目接入，也可以直接复用已有的基建流程，比如 CI 流程、构建和发布流程。这样只需要很少的人来维护所有项目的基建，维护成本也大大减低。</p><p>再者，<strong>团队协作也更加容易</strong>，一方面大家都在一个仓库开发，能够方便地共享和复用代码，方便检索项目源码，另一方面，git commit 的历史记录也支持以功能为单位进行提交，之前对于某个功能的提交，需要改好几个仓库，提交多个 commit，现在只需要提交一次，简化了 commit 记录，方便协作。</p></blockquote>`,48);function k(_,x){const a=l("ExternalLinkIcon");return d(),s("div",null,[u,n("ul",null,[n("li",null,[e("不会重复安装同一个包。用 npm/yarn 的时候，如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。但在使用 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用 "),b,e("(硬链接，不清楚的同学详见"),n("a",v,[e("这篇文章"),i(a)]),e(")。")]),h]),g])}const f=p(m,[["render",k],["__file","packageManager.html.vue"]]);export{f as default};
