import{_ as r,p as t,q as o,s as e,R as a,t as l,Z as n,n as s}from"./framework-1749bed7.js";const p={},c=e("h3",{id:"基本api",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#基本api","aria-hidden":"true"},"#"),a(" 基本API")],-1),d={href:"https://www.runoob.com/jsref/dom-obj-canvas.html",target:"_blank",rel:"noopener noreferrer"},h=n('<p>首先就是 getContext(), 有2d和webGL</p><p>然后就是绘制相关</p><ul><li>直线 (moveTo/lineTo)</li><li>矩形，圆弧，圆，椭圆，贝塞尔曲线</li><li>注意beginPath/closePath 和 clearRect的使用</li><li>可以给线条设置样式，还有渐变透明度等功能</li><li>createPattern 用来绘制图案（可以是图片视频或者其他canvas元素）</li><li>有描边和填充两种方式绘制文字 还可以设置文本样式</li><li>可以设置阴影</li><li>drawImage 绘制图片 还可以缩放裁剪，就是后面的参数</li></ul><p>进阶</p><ul><li><p>save() 和 restore() 对canvas快照保存/恢复</p><p>状态有</p><blockquote><p>应用的变形：移动、旋转、缩放、strokeStyle、fillStyle、globalAlpha、lineWidth、lineCap、lineJoin、miterLimit、lineDashOffset、shadowOffsetX、shadowOffsetY、shadowBlur、shadowColor、globalCompositeOperation、font、textAlign、textBaseline、direction、imageSmoothingEnabled等。</p><p>应用的裁切路径：clipping path</p></blockquote></li><li><p>translate(x, y)、 rotate(angle) 、scale(x, y) 移动/选择/缩放</p></li><li><p>transform、set/reset</p></li><li><p>globalCompositeOperation = type 合成 一堆值</p></li><li><p>clip() 裁剪 可以通过 new Path2D() 来设置裁剪路径</p></li><li><p>定时器 / requestAnimationFrame() 做动画</p></li></ul><h3 id="事件" tabindex="-1"><a class="header-anchor" href="#事件" aria-hidden="true">#</a> 事件</h3><p>canvas可直接添加鼠标/键盘事件</p><ul><li>Mouseover/out 支持冒泡 mouseenter/leave 不支持</li><li>键盘事件可以先让canvas获得焦点 focus</li></ul><h4 id="内部元素" tabindex="-1"><a class="header-anchor" href="#内部元素" aria-hidden="true">#</a> 内部元素</h4><p>就是判断坐标在不在元素内，用 <code>isPointInPath(x, y)</code></p>',10),u={id:"技巧",tabindex:"-1"},v=e("a",{class:"header-anchor",href:"#技巧","aria-hidden":"true"},"#",-1),f={href:"https://juejin.cn/post/7030602892901875743#heading-0",target:"_blank",rel:"noopener noreferrer"},b=n('<blockquote><p>Canvas 最常见的用途是渲染动画。渲染动画的基本原理，无非是反复地擦除和重绘。为了动画的流畅，浏览器留给我们渲染一帧的时间，只有短短的 16ms。在这 16ms 中，我不仅需要处理一些游戏逻辑，计算每个对象的位置、状态，还需要把它们都画出来。如果消耗的时间稍稍多了一些，用户就会感受到「卡顿」。所以，在编写动画的时候，就要格外注重性能</p></blockquote><p>把动画的一帧渲染出来，需要经过以下步骤：</p><ol><li>计算：处理游戏逻辑，计算每个对象的状态，不涉及 DOM 操作（当然也包含对 Canvas 上下文的操作）。</li><li>渲染：真正把对象绘制出来。 2.1. JavaScript 调用 DOM API（包括 Canvas API）以进行渲染。 2.2. 浏览器（通常是另一个渲染线程）把渲染后的结果呈现在屏幕上的过程。（GUI线程而非JS线程）</li></ol><blockquote><p>每一帧的时间只有 16ms。然而，其实我们所做的只是上述的步骤中的 1 和 2.1，而步骤 2.2 则是浏览器在另一个线程（至少几乎所有现代浏览器是这样的）里完成的。动画流畅的真实前提是，以上所有工作都在 16ms 中完成，所以 JavaScript 层面消耗的时间最好控制在 10ms 以内。</p></blockquote><p>通常情况下，渲染比计算的开销大很多（3~4 个量级）。除非用到了一些时间复杂度很高的算法，计算环节的优化没有必要深究。</p><p>我们需要深入研究的，是如何优化渲染的性能。而优化渲染性能的总体思路很简单，归纳为以下几点：</p><ul><li>在每一帧中，尽可能减少调用渲染相关 API 的次数（通常是以计算的复杂化为代价的）。</li><li>在每一帧中，尽可能调用那些渲染开销较低的 API。</li><li>在每一帧中，尽可能以「导致渲染开销较低」的方式调用渲染相关 API。</li></ul><p>我们需要知道的第一件事就是，context 是一个状态机。你可以改变 context 的若干状态，而几乎所有的渲染操作，最终的效果与 context 本身的状态有关系。比如，调用 strokeRect 绘制的矩形边框，边框宽度取决于 context 的状态 lineWidth，而后者是之前设置的。</p><p>Canvas 上下文不是一个普通的对象，比如说，当调用了 context.lineWidth = 5 时，浏览器会需要立刻地做一些事情，这样你、下次调用诸如 stroke 或 strokeRect 等 API 时，画出来的线就正好是 5 个像素宽了（不难想象，这也是一种优化，否则，这些事情就要等到下次 stroke 之前做，更加会影响性能）。</p><p>所以有一点就是，<strong>尽可能少的调用API</strong></p><h4 id="canvas分层" tabindex="-1"><a class="header-anchor" href="#canvas分层" aria-hidden="true">#</a> canvas分层</h4><p>把多个canvas叠在一起，用z-index分层，其实很好理解，就比如说用canvas做了一个小游戏，只有人物在动而背景不动，如果只有一个canvas，每一次动画都会导致背景跟着重新渲染，分层后只需要渲染人物图层就行</p><h4 id="离屏绘制" tabindex="-1"><a class="header-anchor" href="#离屏绘制" aria-hidden="true">#</a> 离屏绘制</h4><p>对于离屏渲染的概念，大多数情况是指：使用一个不可见（或是屏幕外）的 Canvas 对即将渲染的内容的某部分进行提前绘制，然后频繁地将屏幕外图像渲染到主画布上，避免重复生成该部分内容的步骤。直接<code>drawImage()</code>即可</p><p>场景：提前绘制，双Canvas交替绘制，使用<code>OffscreenCanvas</code>达到真正离屏，让canvs运行在web worker线程中</p><h4 id="避免阻塞-js运行时间过长-使用web-worker-拆分任务-放在不同帧中执行" tabindex="-1"><a class="header-anchor" href="#避免阻塞-js运行时间过长-使用web-worker-拆分任务-放在不同帧中执行" aria-hidden="true">#</a> 避免阻塞： JS运行时间过长，使用web worker / 拆分任务 放在不同帧中执行</h4><h4 id="双缓存解决闪烁问题" tabindex="-1"><a class="header-anchor" href="#双缓存解决闪烁问题" aria-hidden="true">#</a> 双缓存解决闪烁问题</h4><p>通过<strong>另外创建一个和主画布等大的缓冲<code>Canvas</code>画布</strong>，需要渲染的图片先绘制到缓冲画布上，然后将缓冲画布的数据直接绘制到主画布上，就解决了闪烁的问题</p><h4 id="局部重绘" tabindex="-1"><a class="header-anchor" href="#局部重绘" aria-hidden="true">#</a> 局部重绘</h4><ol><li>元素互不重叠，只需要重绘需求元素本身</li><li>单个重叠，比如a和b，那就擦除他们的boundingReac</li><li>多个重叠 使用clip</li></ol><ul><li>利用<code>clip</code>裁剪出<code>需要重绘元素</code>的绘制区域</li><li>调用<code>clearRect</code>擦除这块区域</li><li>重绘和这块区域重叠的所有图形</li></ul><p>注意 canvas的transform和c3中不同</p><p>css3中transform是对于单个元素的转换 canvas实际上是对画布的转换，平移实际是对画布原点的重新定位，旋转实际是对画布位置的旋转，缩放实际是对画布大小的缩放，通过对画布的转换来实现对绘制图像的转换，而且这种转换对接下来绘制的所有图像都是成立的，除非我们重置矩阵</p><h3 id="zrender" tabindex="-1"><a class="header-anchor" href="#zrender" aria-hidden="true">#</a> Zrender</h3><p>ZRender 通过以下几个方面对性能进行优化：</p><ul><li><p>图形脏区域管理：ZRender 使用了图形脏区域管理的机制。当图形元素发生变化时，只有受影响的区域会被标记为脏区域，需要重新绘制。这样可以避免不必要的重绘，减少了渲染的工作量，提高了性能。</p></li><li><p>合适的渲染策略：ZRender 根据图形元素的类型和属性，采用了不同的渲染策略。例如，对于简单的图形元素，如矩形或圆形，可以使用批量渲染的方式进行高效绘制。对于复杂的图形元素，如路径或文本，可以使用延迟渲染的方式，只在需要的时候进行渲染，减少了不必要的计算和绘制。</p></li><li><p>硬件加速：ZRender 利用浏览器提供的硬件加速功能，将图形渲染委托给 GPU 进行处理。这样可以充分利用硬件加速的优势，提高图形渲染的性能和效率。</p></li><li><p>动画优化：ZRender 提供了内置的动画 API，用于创建平滑的过渡效果。在动画过程中，ZRender 会根据帧率和动画元素的状态，优化渲染的频率和方式。例如，对于频繁变化的图形元素，可以使用插值计算和帧间差值的方式进行渲染，减少了不必要的绘制操作。</p></li><li><p>缓存和复用：ZRender 对图形元素进行缓存和复用，避免了重复创建和销毁对象的开销。对于相同的图形元素，可以复用已有的对象，减少了内存的占用和垃圾回收的频率，提高了性能。</p></li></ul><p>事件优化：ZRender 通过事件委托和事件分发的方式进行事件处理。它会根据事件的类型和目标元素进行优化，只+ 处理相关的事件，减少了不必要的事件处理和冒泡过程，提高了事件处理的效率。</p><p>这些优化措施使得 ZRender 在大规模图形渲染和复杂交互场景下能够提供良好的性能表现。开发者可以根据具体的需求和场景，灵活地配置和调整这些优化策略，以获得最佳的性能和用户体验。</p><p><strong>要在Canvas上渲染大量节点并优化性能，可以考虑以下几个方面：</strong></p><ul><li><p>使用缓冲区：将要渲染的节点绘制到内存中的缓冲区，然后一次性将整个缓冲区渲染到Canvas上。这样可以减少渲染操作的次数，提高性能。</p></li><li><p>批量绘制：将相似的节点合并为一个单独的图形元素，然后一次性绘制这些图形元素。这样可以减少绘制调用的次数，提高性能。例如，将具有相同样式和属性的节点合并为一个路径进行绘制。</p></li><li><p>使用Web Workers：将渲染操作放在Web Worker中进行，以在后台线程中执行。这样可以避免主线程的阻塞，并提高渲染的并行性能。</p></li><li><p>禁用平滑处理：对于大量的节点渲染，可以禁用平滑处理（antialiasing），这可以提高渲染性能。可以通过设置Canvas的imageSmoothingEnabled属性为false来实现。</p></li><li><p>虚拟化和可见性检测：对于大量节点的情况，可以采用虚拟化技术，只渲染可见区域的节点。通过检测节点是否在可视区域内，只渲染可见的节点，可以显著减少渲染操作的数量。</p></li><li><p>使用GPU加速：利用硬件加速功能，将Canvas渲染操作委托给GPU进行处理，可以提高渲染性能。可以通过使用合适的CSS属性（例如transform: translateZ(0)）或使用WebGL进行渲染来启用GPU加速。</p></li><li><p>优化渲染顺序：根据节点的层叠顺序和重叠情况，合理安排渲染顺序，以减少绘制调用的次数。优先绘制不重叠的节点，然后绘制重叠的节点。</p></li><li><p>数据分析和算法优化：对于复杂的绘制操作，可以进行数据分析，优化算法和数据结构，以减少不必要的计算和渲染操作。</p></li></ul><h3 id="虚拟滚动" tabindex="-1"><a class="header-anchor" href="#虚拟滚动" aria-hidden="true">#</a> 虚拟滚动</h3><p>Canvas虚拟滚动是一种优化技术，用于处理在Canvas上显示大量内容时的性能问题。当需要在Canvas上绘制大量的元素或进行复杂的绘制操作时，会导致性能下降，因为每次渲染都要处理所有的元素或重复进行复杂的绘制操作。</p><p>虚拟滚动通过仅渲染可见区域的内容来解决这个问题。它基于以下原理：在大多数情况下，用户只能看到Canvas上的一小部分内容，而其他部分在当前视图之外。因此，只有可见区域内的内容需要被渲染，而不需要处理整个画布。</p><p>具体实现虚拟滚动的步骤如下：</p><ol><li><p>确定可见区域：首先，确定Canvas上当前可见的区域。这可以通过监听滚动事件或其他交互事件来实现。</p></li><li><p>计算可见元素：根据可见区域的位置和尺寸，计算出在可见区域内应该显示的元素或内容。</p></li><li><p>渲染可见元素：只对计算出的可见元素进行渲染操作，将它们绘制到Canvas上。</p></li></ol><p>通过这种方式，可以避免对整个Canvas进行渲染，从而显著提高性能。虚拟滚动技术适用于需要处理大量元素的情况，例如数据表格、图表、地图等。</p><p>需要注意的是，虚拟滚动并不是Canvas的原生功能，而是一种基于Canvas的性能优化技术，开发者需要自行实现相应的算法和逻辑来实现虚拟滚动效果。</p>',37);function m(_,x){const i=s("ExternalLinkIcon");return t(),o("div",null,[c,e("p",null,[e("a",d,[a("可查询"),l(i)])]),h,e("h3",u,[v,a(),e("a",f,[a("技巧"),l(i)])]),b])}const g=r(p,[["render",m],["__file","canvas.html.vue"]]);export{g as default};
