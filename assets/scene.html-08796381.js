import{_ as t,p as o,q as p,s as n,R as a,t as c,Z as s,n as i}from"./framework-1749bed7.js";const l={},d=s(`<h2 id="实现图片懒加载" tabindex="-1"><a class="header-anchor" href="#实现图片懒加载" aria-hidden="true">#</a> 实现图片懒加载</h2><p>懒加载，顾名思义，在当前网页，滑动页面到能看到图片的时候再加载图片 故问题拆分成两个： 如何判断图片出现在了当前视口 （即如何判断我们能够看到图片） 如何控制图片的加载</p><h3 id="方案一-位置计算-滚动事件-scroll-dataset-api" tabindex="-1"><a class="header-anchor" href="#方案一-位置计算-滚动事件-scroll-dataset-api" aria-hidden="true">#</a> 方案一: 位置计算 + 滚动事件 (Scroll) + DataSet API</h3><p><strong>如何判断图片出现在了当前视口</strong></p><p><code>clientTop</code>，<code>offsetTop</code>，<code>clientHeight</code> 以及 <code>scrollTop</code> 各种关于图片的静态高度作比对 动态高度，监听 <code>window.scroll</code> 事件</p><p><strong>如何控制图片的加载</strong></p><p><code>&lt;img data-src=&quot;shanyue.jpg&quot; /&gt;</code></p><p>首先设置一个临时 Data 属性 <code>data-src</code>，控制加载时使用 <code>src</code> 代替 <code>data-src</code>，可利用 DataSet API 实现</p><p><code>img.src = img.datset.src</code></p><h3 id="方案二-getboundingclientrect-api-scroll-with-throttle-dataset-api" tabindex="-1"><a class="header-anchor" href="#方案二-getboundingclientrect-api-scroll-with-throttle-dataset-api" aria-hidden="true">#</a> 方案二: getBoundingClientRect API + Scroll with Throttle + DataSet API</h3><p><strong>如何判断图片出现在了当前视口</strong></p><p>引入一个新的 API， <code>Element.getBoundingClientRect()</code> 方法返回元素的大小及其相对于视口的位置。</p><p>那如何判断图片出现在了当前视口呢，代码如下。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// clientHeight 代表当前视口的高度</span>
img<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>top <span class="token operator">&lt;</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>如何控制图片的加载</strong></p><p>用节流监听<code>window.scroll</code></p><h3 id="方案三-intersectionobserver-api-dataset-api" tabindex="-1"><a class="header-anchor" href="#方案三-intersectionobserver-api-dataset-api" aria-hidden="true">#</a> 方案三: IntersectionObserver API + DataSet API</h3><p>方案二使用的方法是: <code>window.scroll</code> 监听 <code>Element.getBoundingClientRect()</code> 并使用 <code>throttle</code> 节流</p><p>一系列组合动作太复杂了，于是浏览器出了一个三合一事件: IntersectionObserver API，一个能够监听元素是否到了当前视口的事件.</p><h3 id="方案四-lazyloading" tabindex="-1"><a class="header-anchor" href="#方案四-lazyloading" aria-hidden="true">#</a> 方案四: LazyLoading</h3><p>浏览器自己的一个属性，不过兼容性一般</p><h2 id="实现浏览器复制" tabindex="-1"><a class="header-anchor" href="#实现浏览器复制" aria-hidden="true">#</a> 实现浏览器复制</h2><p>这个简单</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>navigator<span class="token punctuation">.</span>clipboard<span class="token punctuation">.</span><span class="token function">writeText</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="把json数据转化成demo-json文件并下载" tabindex="-1"><a class="header-anchor" href="#把json数据转化成demo-json文件并下载" aria-hidden="true">#</a> 把JSON数据转化成demo.json文件并下载</h2><ol><li>模拟下载，可以通过新建一个 <code>&lt;a href=&quot;url&quot; download&gt;&lt;a&gt;</code> 标签并设置 url 及 download 属性来下载</li><li>可以通过把 json 转化为 <code>dataurl</code> 来构造 URL</li><li>可以通过把 json 转换为 <code>Blob</code> 再转化为 <code>ObjectURL</code> 来构造 URL</li></ol><h2 id="简单介绍-requestidlecallback-及使用场景" tabindex="-1"><a class="header-anchor" href="#简单介绍-requestidlecallback-及使用场景" aria-hidden="true">#</a> 简单介绍 requestIdleCallback 及使用场景</h2><p><code>requestIdleCallback </code>维护一个队列，将在浏览器空闲时间内执行。它属于 <code>Background Tasks API</code>，可以使setTimeout来模拟</p><p>在 rIC 中执行任务时需要注意以下几点：</p>`,29),r={href:"https://github.com/facebook/react/tree/main/packages/scheduler",target:"_blank",rel:"noopener noreferrer"},u=s(`<h2 id="如何计算白屏时间和首屏时间" tabindex="-1"><a class="header-anchor" href="#如何计算白屏时间和首屏时间" aria-hidden="true">#</a> 如何计算白屏时间和首屏时间</h2><p>白屏时间: window.performance.timing.domLoading - window.performance.timing.navigationStart</p><p>首屏时间: window.performance.timing.domInteractive - window.performace.timing.navigationStart</p><h2 id="什么是-data-url" tabindex="-1"><a class="header-anchor" href="#什么是-data-url" aria-hidden="true">#</a> 什么是 Data URL</h2><p>Data URL 是将图片转换为 base64 直接嵌入到了网页中，使用<img src="data:[MIME type];base64">这种方式引用图片，不需要再发请求获取图片。 使用 Data URL 也有一些缺点：</p><ul><li>base64 编码后的图片会比原来的体积大三分之一左右。</li><li>Data URL 形式的图片不会缓存下来，每次访问页面都要被下载一次。可以将 Data URL 写入到 CSS 文件中随着 CSS 被缓存下来。</li></ul><p>Data URL 是前缀为data:协议的 URL； 它允许内容创建者向文档中嵌入小文件，比如图片等。 Data URL 由四部分组成：</p><ul><li>前缀data:</li><li>指示数据类型的 MIME 类型。例如image/jpeg表示 JPEG 图像文件；如果此部分被省略，则默认值为text/plain;charset=US-SACII</li><li>如果为非文本数据，则可选 base64 做标记</li><li>数据 <code>data:[mediatype][;base63], data</code></li></ul><h2 id="在-canvas-中如何处理跨域的图片" tabindex="-1"><a class="header-anchor" href="#在-canvas-中如何处理跨域的图片" aria-hidden="true">#</a> 在 Canvas 中如何处理跨域的图片</h2><p><code>img.setAttribute(&quot;crossOrigin&quot;, &quot;anonymous&quot;);</code></p><h2 id="如何取消请求的发送" tabindex="-1"><a class="header-anchor" href="#如何取消请求的发送" aria-hidden="true">#</a> 如何取消请求的发送</h2><p>根据发送网络请求的 API 不同，取消方法不同</p><ul><li>xhr</li><li>fetch</li><li>axios 如果使用XMLHttpRequest发送请求可以使用XMLHttpRequest.abort()</li></ul><p>如果使用fetch发送请求可以使用AbortController</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> controller <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AbortController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> signal <span class="token operator">=</span> controller<span class="token punctuation">.</span>signal<span class="token punctuation">;</span>
<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;https://somewhere&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> signal <span class="token punctuation">}</span><span class="token punctuation">)</span>
controller<span class="token punctuation">.</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用<code>axios</code>，取消原理同 fetch</p><h1 id="大文件上传" tabindex="-1"><a class="header-anchor" href="#大文件上传" aria-hidden="true">#</a> 大文件上传</h1><p>核心是<code>利用 Blob.prototype.slice</code> 方法</p><p>预先定义好单个切片大小，将文件切分为一个个切片，然后借助 http 的可并发性，同时上传多个切片。这样从原本传一个大文件，变成了<code>并发</code>传多个小的文件切片，可以大大减少上传时间</p><p>另外由于是并发，传输到服务端的顺序可能会发生变化，因此我们还需要给每个切片记录顺序</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">SIZE</span> <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>     
<span class="token comment">// 生成文件切片</span>
<span class="token function">createFileChunk</span><span class="token punctuation">(</span><span class="token parameter">file<span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token constant">SIZE</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> fileChunkList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;</span> file<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fileChunkList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">file</span><span class="token operator">:</span> file<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> cur <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cur  <span class="token operator">=</span> size<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> fileChunkList<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 上传切片</span>
  <span class="token keyword">async</span> <span class="token function">uploadChunks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> requestList <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> chunk，hash <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;chunk&quot;</span><span class="token punctuation">,</span> chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
      formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;hash&quot;</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
      formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;filename&quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>container<span class="token punctuation">.</span>file<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span> formData <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> formData <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">&quot;http://localhost:3000&quot;</span><span class="token punctuation">,</span>
      <span class="token literal-property property">data</span><span class="token operator">:</span> formData
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 并发请求</span>
    <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>requestList<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="断点续传" tabindex="-1"><a class="header-anchor" href="#断点续传" aria-hidden="true">#</a> 断点续传</h3><p>断点续传指的是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障或页面刷新，可以从已经上传或下载的部分开始继续上传下载未完成的部分，用户可以节省时间，提高速度。</p><blockquote><p>断点续传的原理在于前端/服务端需要<code>记住</code>已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能</p><ul><li>前端使用 localStorage 记录已上传的切片 hash</li><li>服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片</li></ul><p>第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选后者</p><p><code>之前我们使用文件名 + 切片下标作为切片 hash</code>，这样做文件名一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是<code>根据文件内容生成 hash</code>，所以我们修改一下 hash 的生成规则</p><p>考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会<code>引起 UI 的阻塞</code>，导致页面假死状态，所以我们使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互</p></blockquote><h1 id="前端水印" tabindex="-1"><a class="header-anchor" href="#前端水印" aria-hidden="true">#</a> 前端水印</h1><h5 id="重复的dom元素覆盖实现" tabindex="-1"><a class="header-anchor" href="#重复的dom元素覆盖实现" aria-hidden="true">#</a> 重复的dom元素覆盖实现</h5><p>从效果开始，要实现的效果是「在页面上充满透明度较低的重复的代表身份的信息」，第一时间想到的方案是在页面上覆盖一个position:fixed的div盒子，盒子透明度设置较低，设置pointer-events: none;样式实现点击穿透，在这个盒子内通过js循环生成小的水印div，每个水印div内展示一个要显示的水印内容</p><h5 id="canvas-svg-输出背景图" tabindex="-1"><a class="header-anchor" href="#canvas-svg-输出背景图" aria-hidden="true">#</a> canvas / svg 输出背景图</h5><p>第一步还是在页面上覆盖一个固定定位的盒子，然后创建一个canvas画布，绘制出一个水印区域，将这个水印通过toDataURL方法输出为一个图片，将这个图片设置为盒子的背景图，通过backgroud-repeat：repeat；样式实现填满整个屏幕的效果</p><blockquote><p>但是，以上三种方法存在一个共同的问题，由于是前端生成dom元素覆盖到页面上的，对于有些前端知识的人来说，可以在开发者工具中找到水印所在的元素，将元素整个删掉，以达到删除页面上的水印的目的，针对这个问题，我想到了一个很笨的办法：设置定时器，每隔几秒检验一次我们的水印元素还在不在，有没有被修改，如果发生了变化则再执行一次覆盖水印的方法。网上看到了另一种解决方法：使用MutationObserver</p><p>MutationObserver是变动观察器，字面上就可以理解这是用来观察节点变化的。Mutation Observer API 用来监视 DOM 变动，DOM 的任何变动，比如子节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。</p><p>但是MutationObserver只能监测到诸如属性改变、子结点变化等，对于自己本身被删除，是没有办法监听的，这里可以通过监测父结点来达到要求。</p></blockquote><h5 id="图片加水印-圣诞树使用的方法" tabindex="-1"><a class="header-anchor" href="#图片加水印-圣诞树使用的方法" aria-hidden="true">#</a> 图片加水印(圣诞树使用的方法)</h5><p>有时我们需要在图片上加水印用来标示归属或者其他信息，在图片上加水印的实现思路是，图片加载成功后画到canvas中，随后在canvas中绘制水印，完成后通过canvas.toDataUrl()方法获得base64并替换原来的图片路径</p><p>设计模式</p><p>https://juejin.cn/post/7072175210874535967</p><h1 id="token鉴权相关" tabindex="-1"><a class="header-anchor" href="#token鉴权相关" aria-hidden="true">#</a> Token鉴权相关</h1><h3 id="token" tabindex="-1"><a class="header-anchor" href="#token" aria-hidden="true">#</a> token</h3><p>&quot;token&quot;通常是指一个字符串或数字，它用于验证和授权访问资源的身份验证凭据。当一个用户进行登录或者请求访问一个受保护的资源时，系统通常会生成一个token，并将其返回给用户。这个token在之后的请求中被用来验证用户的身份和授权。</p><p>在实际应用中，token通常需要加密或签名来保证其不被篡改或伪造。加密的方法通常有很多种，其中比较常用的是使用对称密钥加密算法，例如AES或者DES等。在这种加密方式下，系统将一个密钥存储在服务端，并用这个密钥对token进行加密。用户在每次请求时，都将token发送给服务端，并由服务端使用相同的密钥解密token。这样就能够确保token不会被其他人篡改或者伪造。</p><p>此外，还有一些基于非对称密钥加密算法的方法来加密token，例如RSA。在这种方法下，服务端使用自己的私钥对token进行加密，而客户端使用服务端的公钥来解密token。这种方法的优点是能够避免密钥的泄露问题，但是加密和解密的速度较慢，适用性不如对称密钥加密算法。</p><h3 id="如何防止token泄漏" tabindex="-1"><a class="header-anchor" href="#如何防止token泄漏" aria-hidden="true">#</a> 如何防止token泄漏</h3><ol><li>使用https协议：使用https协议可以对网络传输进行加密，有效地防止了中间人攻击和窃听，保障了token的安全。</li><li>不在前端存储敏感信息：不建议将敏感信息如token存储在前端本地存储，比如localStorage、sessionStorage等，可以将其存储在后端session或redis等缓存中。</li><li>使用token有效期：可以设置token的有效期，在有效期内token才能被使用，过期后需要重新登录获取新的token。</li><li>对请求进行身份验证：服务端可以对请求进行身份验证，验证token的正确性和有效期，只有验证通过的请求才能得到响应。</li><li>增加token的复杂度：增加token的复杂度可以提高token的安全性，可以增加唯独，比如IP或者主机号</li><li>使用单独的token：对于不同的应用场景可以使用不同的token，这样即使某一个token泄漏了，也只会影响对应的应用场景，降低了整个系统的安全风险。</li></ol><h3 id="鉴权方案" tabindex="-1"><a class="header-anchor" href="#鉴权方案" aria-hidden="true">#</a> 鉴权方案</h3><ol><li><p>基于Token的鉴权：在用户登录成功后，服务端颁发一个Token，客户端每次请求时需要携带这个Token，服务端验证Token的有效性来判断是否允许访问。</p></li><li><p>基于Cookie的鉴权：在用户登录成功后，服务端返回一个带有用户信息的Cookie，客户端每次请求时会自动携带这个Cookie，服务端验证Cookie的有效性来判断是否允许访问。</p></li><li><p>基于Session的鉴权：在用户登录成功后，服务端在后台为该用户创建一个Session，客户端每次请求时需要携带SessionID，服务端验证Session的有效性来判断是否允许访问。</p></li><li><p>基于OAuth2的鉴权：OAuth2是一种授权机制，允许第三方应用在用户授权的情况下，通过访问用户授权的API资源，实现数据共享。OAuth2通常用于实现授权码模式、密码模式等多种鉴权方式。</p></li></ol><h3 id="jwt" tabindex="-1"><a class="header-anchor" href="#jwt" aria-hidden="true">#</a> JWT</h3><p>JWT是<code>json web token</code>缩写。它将用户信息加密到<code>token</code>里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证<code>token</code>的正确性，只要正确即通过验证。</p><p>JWT包含三个部分： <code>Header</code>头部，<code>Payload</code>负载和<code>Signature</code>签名。由三部分生成<code>token</code>，三部分之间用“<code>.</code>”号做分割。</p><ul><li><p><code>Header</code> 声明信息。 在<code>Header</code>中通常包含了两部分：<code>type</code>：代表<code>token</code>的类型，这里使用的是<code>JWT</code>类型。 alg:使用的<code>Hash</code>算法，例如<code>HMAC SHA256</code>或<code>RSA</code>. <code>{ “alg”: “HS256”, “typ”: “JWT” }</code> 这会被经过base64Url编码形成第一部分</p></li><li><p><code>Payload token</code>的第二个部分是荷载信息，它包含一些声明Claim(实体的描述，通常是一个<code>User</code>信息，还包括一些其他的元数据) 声明分三类: 1)<code>Reserved Claims</code>,这是一套预定义的声明，并不是必须的,这是一套易于使用、操作性强的声明。包括：<code>iss(issuer)、exp(expiration time)、sub(subject)、aud(audience)</code>等 2)<code>Plubic Claims</code>, 3)<code>Private Claims</code>,交换信息的双方自定义的声明 <code>{ “sub”: “1234567890”, “name”: “John Doe”,“admin”: true }</code> 同样经过<code>Base64Url</code>编码后形成第二部分</p></li><li><p><code>signature</code> 使用<code>header</code>中指定的算法将编码后的<code>header</code>、编码后的<code>payload</code>、用<code>secret</code>进行加密。例如使用的是<code>HMAC SHA256</code>算法，大致流程类似于: <code>HMACSHA256( base64UrlEncode(header) + “.” + base64UrlEncode(payload),secret)</code>这个<code>signature</code>字段被用来确认<code>JWT</code>信息的发送者是谁，并保证信息没有被修改 。</p></li><li><p>验证流程：</p><ul><li>在头部信息中声明加密算法和常量，然后把<code>header</code>使用<code>json</code>转化为字符串</li><li>在载荷中声明用户信息，同时还有一些其他的内容，再次使用json把在和部分进行转化，转化为字符串</li><li>使用在<code>header</code>中声明的加密算法来进行加密，把第一部分字符串和第二部分的字符串结合和每个项目随机生成的<code>secret</code>字符串进行加密，生成新的字符串，此字符串是独一无二的</li><li>解密的时候，只要客户端带着<code>jwt</code>来发起请求，服务端就直接使用<code>secret</code>进行解密，解签证解出第一部分和第二部分，然后比对第二部分的信息和客户端穿过来的信息是否一致。如果一致验证成功，否则验证失败。</li></ul><p>特点：</p><ul><li>三部分组成，每一部分都进行字符串的转化</li><li>解密的时候没有使用数据库，仅仅使用的是<code>secret</code>进行解密</li><li><code>Jwt</code>使用的<code>secret</code>千万不能丢失</li></ul><h1 id="低代码方案" tabindex="-1"><a class="header-anchor" href="#低代码方案" aria-hidden="true">#</a> 低代码方案</h1><p>可视化编辑器是前端低代码方案中常见的一种实现方式，可以通过可视化界面拖拽、拖拽组件，直观地搭建页面。同时，可视化编辑器通常会为开发者提供实时预览功能，以便及时查看页面的效果。</p><p>模板化设计则是通过提前设计好一系列的页面模板，并让开发者在此基础上进行修改的方式，以提高开发效率。开发者可以基于已有的模板进行修改，而不需要从零开始编写页面。</p><p>自动生成代码则是前端低代码方案中非常重要的一部分，通过预设好的逻辑和规则，让系统自动生成相应的代码。这种方式可以避免开发者重复编写大量的重复代码，提高代码质量和开发效率。</p><h1 id="restful" tabindex="-1"><a class="header-anchor" href="#restful" aria-hidden="true">#</a> RESTFUL</h1><p><code>REST</code>，全名 <code>Representational State Transfer</code>(表现层状态转移)，他是一种<strong>设计风格</strong>，一种<strong>软件架构风格</strong>，而<strong>不是标准</strong>，只是<strong>提供了一组设计原则和约束条件</strong>。</p><p><code>RESTful API</code> 就是满足 <code>REST </code>风格的，以此规范设计的 <code>API</code>。</p><p>普通</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e5e2e9dccc44a99a97009932cc624c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p><p>RESTFUL</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df3dffda154247b491dbd7ef2fe786e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p><p>缺点：</p><p>1、RESTful是面向资源的，所以接口都是一些名词，尤指复数名词。简单的CRUD还是很合适的，但很多业务逻辑都很难将其抽象为资源。比如说登录/登出，怎么看也不是一个资源，如果硬是抽象为创建一个session/删除一个session。这不仅反直觉，还违背了RESTful的思想。</p><p>2、RESTful只提供了基本的增删改查，对于复杂的逻辑是一点办法没有，比如批量下载、批量删除等。对于复杂的查询，更是无从下手。而且开发时会面临诸多选择，修改资源用PUT还是PETCH？采用查询参数还是用body？</p><p>3、关于错误码的问题更是复杂的一批，RESTful建议使用status code作为错误码，以便统一。在实际开发中，业务逻辑的含义数不胜数，很难统一。比如400状态码到底是表示传参有问题，还是该资源已被占用了。404是表示接口不存在，还是资源不存在。</p></li></ul>`,47);function k(h,m){const e=i("ExternalLinkIcon");return o(),p("div",null,[d,n("p",null,[a("执行重计算而非紧急任务 空闲回调执行时间应该小于 50ms，最好更少 空闲回调中不要操作 DOM，因为它本来就是利用的重排重绘后的间隙空闲时间，重新操作 DOM 又会造成重排重绘 React 的时间分片便是基于类似 rIC 而实现，然而因为 rIC 的兼容性及 50ms 流畅问题，React 自制了一个实现:"),n("a",r,[a("scheduler "),c(e)])]),u])}const b=t(l,[["render",k],["__file","scene.html.vue"]]);export{b as default};
