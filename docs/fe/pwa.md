PWA（Progressive Web App）**渐进式Web应用程序**

浏览器的三大进化路线：

- 第一个是应用程序 Web 化；
- 第二个是 Web 应用移动化；
- 第三个是 Web 操作系统化；

简单解释一下，第一个很好理解，我们现在用的各种云文档，什么飞书啊金山啊腾讯啊，这些应用其实都脱胎于微软的Office吧，那Office一开始不就仅仅是一个windows桌面应用吗。

第二个其实是各大浏览器厂商想做又比较难做到的事，因为在移动端应用上有App和小程序这俩地头蛇和过江龙摆在这，移动端浏览器应用就很难脱颖而出抢占市场，而PWA就是用来做这个事情的。

第三个了解的就比较少了，也比较高级比较难，引用一下GPT的说法

> Web 操作系统化：这个进化路线指的是将浏览器变成一个完整的操作系统，从而使得用户可以在浏览器中运行各种应用程序，而不需要安装本地的操作系统或应用程序。这样的应用程序通常被称为 Web 操作系统或浏览器操作系统。一个典型的例子是 Chrome OS，它是 Google 推出的一款基于浏览器的操作系统，可以运行各种 Web 应用和 Chrome 浏览器扩展程序。

那PWA中的WA都了解了，那如何理解P渐进式呢？

> - 站在 Web 应用开发者来说，PWA 提供了一个渐进式的过渡方案，让普通站点逐步过渡到 Web 应用。采取渐进式可以降低站点改造的代价，使得站点逐步支持各项新技术，而不是一步到位。
> - 站在技术角度来说，PWA 技术也是一个渐进式的演化过程，在技术层面会一点点演进，比如逐渐提供更好的设备特性支持，不断优化更加流畅的动画效果，不断让页面的加载速度变得更快，不断实现本地应用的特性。
>
> 从这两点可以看出来，PWA 采取的是非常一个缓和的渐进式策略，不再像以前那样激进，动不动就是取代本地 App、取代小程序。与之相反，而是要充分发挥 Web 的优势，渐进式地缩短和本地应用或者小程序的距离
>
> **它是一套理念，渐进式增强 Web 的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离**。基于这套理念之下的技术都可以归类到 PWA

可以先思考，为什么PWA撼动不了APP和小程序，web应用在移动端的缺陷和痛点是什么？

> - 首先，Web 应用缺少离线使用能力，在离线或者在弱网环境下基本上是无法使用的。而用户需要的是沉浸式的体验，在离线或者弱网环境下能够流畅地使用是用户对一个应用的基本要求。
> - 其次，Web 应用还缺少了消息推送的能力，因为作为一个 App 厂商，需要有将消息送达到应用的能力。
> - 最后，Web 应用缺少一级入口，也就是将 Web 应用安装到桌面，在需要的时候直接从桌面打开 Web 应用，而不是每次都需要通过浏览器来打开。
>
> **针对以上 Web 缺陷，PWA 提出了两种解决方案：通过引入 Service Worker 来试着解决离线存储和消息推送的问题，通过引入 manifest.json 来解决一级入口的问题**。



+ 消息推送的解决

1. 注册推送服务：在 Service Worker 中注册推送服务，向浏览器申请推送通知权限，并将推送服务的配置信息发送给服务器。
2. 监听推送消息：在 Service Worker 中监听推送服务的消息，当接收到消息时，可以使用 Notification API 显示通知，或者在应用中处理消息。
3. 处理消息：在应用中处理推送消息，可以根据消息内容进行不同的操作，比如更新数据、显示通知等。

+ 一级入口的解决

使用**Web App Manifest**

manifest.json 是一个 Web App Manifest 文件，它是一种 JSON 格式的文件，用于描述 Web 应用的相关信息，比如应用名称、图标、主题色、启动方式等。Web App Manifest 可以让浏览器识别 Web 应用，并且将其添加到主屏幕或桌面上，从而实现类似原生应用的使用体验。

Web App Manifest 文件通常包括以下几个属性：

1. name：应用名称。

2. short_name：应用短名称，通常在主屏幕或桌面上显示。

3. start_url：应用的启动 URL。

4. display：应用的启动方式，包括 browser、fullscreen、standalone 等几种方式。

5. background_color：应用的背景色。

6. theme_color：应用的主题色。

7. icons：应用的图标列表，包括多种尺寸和类型的图标。

8. description：应用的描述信息。

9. orientation：应用的屏幕方向。

10. lang：应用的语言。

在 Web App Manifest 文件中，必须设置 name、short_name、start_url、display 四个属性。其他属性是可选的，但是它们可以为用户提供更好的使用体验。

在浏览器中，可以通过以下方式来识别和添加 Web App Manifest 文件：

1. 在 HTML 页面中使用 link 标签引入 manifest.json 文件。

2. 在 HTTP 响应头中添加 manifest.json 文件的链接，比如：Link: <path/to/manifest.json>; rel="manifest"。

使用 Web App Manifest 文件，可以让 Web 应用在浏览器中像本地应用一样添加到主屏幕或桌面，并且可以在离线状态下访问，实现类似原生应用的使用体验。



我们知道 JavaScript 和页面渲染流水线的任务都是在页面主线程上执行的，如果一段 JavaScript 执行时间过久，那么就会阻塞主线程，使得渲染一帧的时间变长，从而让用户产生卡顿的感觉，这对用户来说体验是非常不好的。

为了避免 JavaScript 过多占用页面主线程时长的情况，浏览器实现了 Web Worker 的功能。Web Worker 的目的是让 JavaScript 能够运行在页面主线程之外，不过由于 Web Worker 中是没有当前页面的 DOM 环境的，所以在 Web Worker 中只能执行一些和 DOM 无关的 JavaScript 脚本，并通过 postMessage 方法将执行的结果返回给主线程。所以说在 Chrome 中， Web Worker 其实就是在渲染进程中开启的一个新线程，它的生命周期是和页面关联的。

**“让其运行在主线程之外”就是 Service Worker 来自 Web Worker 的一个核心思想**。不过 Web Worker 是临时的，每次 JavaScript 脚本执行完成之后都会退出，执行结果也不能保存下来，如果下次还有同样的操作，就还得重新来一遍。所以 Service Worker 需要在 Web Worker 的基础之上加上储存功能。

另外，由于 Service Worker 还需要会为多个页面提供服务，所以还**不能把 Service Worker 和单个页面绑定起来**。在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务。



Service Worker只能在HTTPS协议下使用是因为Service Worker拦截网络请求、代理响应和访问缓存等行为能够使得恶意攻击者轻易地对网络流量进行篡改或者窃听，从而使得用户数据泄露、页面被篡改等情况发生。使用HTTPS协议可以确保网络通信的安全性，防止网络中的中间人攻击和数据窃听，从而保护用户的隐私和安全。

HTTPS协议通过使用SSL/TLS协议对网络通信进行加密，使得网络数据传输过程中的数据不可被窃听和篡改。而对于HTTP协议，由于数据是明文传输的，所以容易受到网络攻击的威胁。

因此，为了保证Service Worker的安全性和可靠性，浏览器限制了Service Worker只能在HTTPS协议下使用。这确保了Service Worker的安全性，使得浏览器和用户能够信任Service Worker所提供的服务。

