---
title: Canvas学习
---
### 基本API
[可查询](https://www.runoob.com/jsref/dom-obj-canvas.html)

首先就是 getContext(), 有2d和webGL

然后就是绘制相关

+ 直线 (moveTo/lineTo)
+ 矩形，圆弧，圆，椭圆，贝塞尔曲线
+ 注意beginPath/closePath 和 clearRect的使用
+ 可以给线条设置样式，还有渐变透明度等功能
+ createPattern 用来绘制图案（可以是图片视频或者其他canvas元素）
+ 有描边和填充两种方式绘制文字 还可以设置文本样式
+ 可以设置阴影
+ drawImage 绘制图片 还可以缩放裁剪，就是后面的参数

进阶

+ save() 和 restore() 对canvas快照保存/恢复

  状态有

  > 应用的变形：移动、旋转、缩放、strokeStyle、fillStyle、globalAlpha、lineWidth、lineCap、lineJoin、miterLimit、lineDashOffset、shadowOffsetX、shadowOffsetY、shadowBlur、shadowColor、globalCompositeOperation、font、textAlign、textBaseline、direction、imageSmoothingEnabled等。
  >
  > 应用的裁切路径：clipping path

+ translate(x, y)、 rotate(angle) 、scale(x, y) 移动/选择/缩放

+ transform、set/reset

+ globalCompositeOperation = type 合成 一堆值

+ clip() 裁剪 可以通过 new Path2D() 来设置裁剪路径

+ 定时器 / requestAnimationFrame() 做动画

### 事件

canvas可直接添加鼠标/键盘事件

+ Mouseover/out 支持冒泡 mouseenter/leave 不支持
+ 键盘事件可以先让canvas获得焦点 focus

#### 内部元素

就是判断坐标在不在元素内，用 `isPointInPath(x, y)`

### [技巧](https://juejin.cn/post/7030602892901875743#heading-0)

>Canvas 最常见的用途是渲染动画。渲染动画的基本原理，无非是反复地擦除和重绘。为了动画的流畅，浏览器留给我们渲染一帧的时间，只有短短的 16ms。在这 16ms 中，我不仅需要处理一些游戏逻辑，计算每个对象的位置、状态，还需要把它们都画出来。如果消耗的时间稍稍多了一些，用户就会感受到「卡顿」。所以，在编写动画的时候，就要格外注重性能

把动画的一帧渲染出来，需要经过以下步骤：
1. 计算：处理游戏逻辑，计算每个对象的状态，不涉及 DOM 操作（当然也包含对 Canvas 上下文的操作）。
2. 渲染：真正把对象绘制出来。
  2.1. JavaScript 调用 DOM API（包括 Canvas API）以进行渲染。
  2.2. 浏览器（通常是另一个渲染线程）把渲染后的结果呈现在屏幕上的过程。（GUI线程而非JS线程）

> 每一帧的时间只有 16ms。然而，其实我们所做的只是上述的步骤中的 1 和 2.1，而步骤 2.2 则是浏览器在另一个线程（至少几乎所有现代浏览器是这样的）里完成的。动画流畅的真实前提是，以上所有工作都在 16ms 中完成，所以 JavaScript 层面消耗的时间最好控制在 10ms 以内。

通常情况下，渲染比计算的开销大很多（3~4 个量级）。除非用到了一些时间复杂度很高的算法，计算环节的优化没有必要深究。

我们需要深入研究的，是如何优化渲染的性能。而优化渲染性能的总体思路很简单，归纳为以下几点：

+ 在每一帧中，尽可能减少调用渲染相关 API 的次数（通常是以计算的复杂化为代价的）。
+ 在每一帧中，尽可能调用那些渲染开销较低的 API。
+ 在每一帧中，尽可能以「导致渲染开销较低」的方式调用渲染相关 API。

我们需要知道的第一件事就是，context 是一个状态机。你可以改变 context 的若干状态，而几乎所有的渲染操作，最终的效果与 context 本身的状态有关系。比如，调用 strokeRect 绘制的矩形边框，边框宽度取决于 context 的状态 lineWidth，而后者是之前设置的。

Canvas 上下文不是一个普通的对象，比如说，当调用了 context.lineWidth = 5 时，浏览器会需要立刻地做一些事情，这样你、下次调用诸如 stroke 或 strokeRect 等 API 时，画出来的线就正好是 5 个像素宽了（不难想象，这也是一种优化，否则，这些事情就要等到下次 stroke 之前做，更加会影响性能）。

所以有一点就是，**尽可能少的调用API**

#### canvas分层

把多个canvas叠在一起，用z-index分层，其实很好理解，就比如说用canvas做了一个小游戏，只有人物在动而背景不动，如果只有一个canvas，每一次动画都会导致背景跟着重新渲染，分层后只需要渲染人物图层就行

#### 离屏绘制
对于离屏渲染的概念，大多数情况是指：使用一个不可见（或是屏幕外）的 Canvas 对即将渲染的内容的某部分进行提前绘制，然后频繁地将屏幕外图像渲染到主画布上，避免重复生成该部分内容的步骤。直接`drawImage()`即可

场景：提前绘制，双Canvas交替绘制，使用`OffscreenCanvas`达到真正离屏，让canvs运行在web worker线程中


#### 避免阻塞： JS运行时间过长，使用web worker / 拆分任务 放在不同帧中执行

#### 双缓存解决闪烁问题

通过**另外创建一个和主画布等大的缓冲`Canvas`画布**，需要渲染的图片先绘制到缓冲画布上，然后将缓冲画布的数据直接绘制到主画布上，就解决了闪烁的问题

#### 局部重绘

1. 元素互不重叠，只需要重绘需求元素本身
2. 单个重叠，比如a和b，那就擦除他们的boundingReac
3. 多个重叠 使用clip

- 利用`clip`裁剪出`需要重绘元素`的绘制区域
- 调用`clearRect`擦除这块区域
- 重绘和这块区域重叠的所有图形

注意 canvas的transform和c3中不同

css3中transform是对于单个元素的转换
canvas实际上是对画布的转换，平移实际是对画布原点的重新定位，旋转实际是对画布位置的旋转，缩放实际是对画布大小的缩放，通过对画布的转换来实现对绘制图像的转换，而且这种转换对接下来绘制的所有图像都是成立的，除非我们重置矩阵

### Zrender
ZRender 通过以下几个方面对性能进行优化：

+ 图形脏区域管理：ZRender 使用了图形脏区域管理的机制。当图形元素发生变化时，只有受影响的区域会被标记为脏区域，需要重新绘制。这样可以避免不必要的重绘，减少了渲染的工作量，提高了性能。

+ 合适的渲染策略：ZRender 根据图形元素的类型和属性，采用了不同的渲染策略。例如，对于简单的图形元素，如矩形或圆形，可以使用批量渲染的方式进行高效绘制。对于复杂的图形元素，如路径或文本，可以使用延迟渲染的方式，只在需要的时候进行渲染，减少了不必要的计算和绘制。

+ 硬件加速：ZRender 利用浏览器提供的硬件加速功能，将图形渲染委托给 GPU 进行处理。这样可以充分利用硬件加速的优势，提高图形渲染的性能和效率。

+ 动画优化：ZRender 提供了内置的动画 API，用于创建平滑的过渡效果。在动画过程中，ZRender 会根据帧率和动画元素的状态，优化渲染的频率和方式。例如，对于频繁变化的图形元素，可以使用插值计算和帧间差值的方式进行渲染，减少了不必要的绘制操作。

+ 缓存和复用：ZRender 对图形元素进行缓存和复用，避免了重复创建和销毁对象的开销。对于相同的图形元素，可以复用已有的对象，减少了内存的占用和垃圾回收的频率，提高了性能。

事件优化：ZRender 通过事件委托和事件分发的方式进行事件处理。它会根据事件的类型和目标元素进行优化，只+ 处理相关的事件，减少了不必要的事件处理和冒泡过程，提高了事件处理的效率。

这些优化措施使得 ZRender 在大规模图形渲染和复杂交互场景下能够提供良好的性能表现。开发者可以根据具体的需求和场景，灵活地配置和调整这些优化策略，以获得最佳的性能和用户体验。


**要在Canvas上渲染大量节点并优化性能，可以考虑以下几个方面：**

+ 使用缓冲区：将要渲染的节点绘制到内存中的缓冲区，然后一次性将整个缓冲区渲染到Canvas上。这样可以减少渲染操作的次数，提高性能。

+ 批量绘制：将相似的节点合并为一个单独的图形元素，然后一次性绘制这些图形元素。这样可以减少绘制调用的次数，提高性能。例如，将具有相同样式和属性的节点合并为一个路径进行绘制。

+ 使用Web Workers：将渲染操作放在Web Worker中进行，以在后台线程中执行。这样可以避免主线程的阻塞，并提高渲染的并行性能。

+ 禁用平滑处理：对于大量的节点渲染，可以禁用平滑处理（antialiasing），这可以提高渲染性能。可以通过设置Canvas的imageSmoothingEnabled属性为false来实现。

+ 虚拟化和可见性检测：对于大量节点的情况，可以采用虚拟化技术，只渲染可见区域的节点。通过检测节点是否在可视区域内，只渲染可见的节点，可以显著减少渲染操作的数量。

+ 使用GPU加速：利用硬件加速功能，将Canvas渲染操作委托给GPU进行处理，可以提高渲染性能。可以通过使用合适的CSS属性（例如transform: translateZ(0)）或使用WebGL进行渲染来启用GPU加速。

+ 优化渲染顺序：根据节点的层叠顺序和重叠情况，合理安排渲染顺序，以减少绘制调用的次数。优先绘制不重叠的节点，然后绘制重叠的节点。

+ 数据分析和算法优化：对于复杂的绘制操作，可以进行数据分析，优化算法和数据结构，以减少不必要的计算和渲染操作。

### 虚拟滚动
Canvas虚拟滚动是一种优化技术，用于处理在Canvas上显示大量内容时的性能问题。当需要在Canvas上绘制大量的元素或进行复杂的绘制操作时，会导致性能下降，因为每次渲染都要处理所有的元素或重复进行复杂的绘制操作。

虚拟滚动通过仅渲染可见区域的内容来解决这个问题。它基于以下原理：在大多数情况下，用户只能看到Canvas上的一小部分内容，而其他部分在当前视图之外。因此，只有可见区域内的内容需要被渲染，而不需要处理整个画布。

具体实现虚拟滚动的步骤如下：

1. 确定可见区域：首先，确定Canvas上当前可见的区域。这可以通过监听滚动事件或其他交互事件来实现。

2. 计算可见元素：根据可见区域的位置和尺寸，计算出在可见区域内应该显示的元素或内容。

3. 渲染可见元素：只对计算出的可见元素进行渲染操作，将它们绘制到Canvas上。

通过这种方式，可以避免对整个Canvas进行渲染，从而显著提高性能。虚拟滚动技术适用于需要处理大量元素的情况，例如数据表格、图表、地图等。

需要注意的是，虚拟滚动并不是Canvas的原生功能，而是一种基于Canvas的性能优化技术，开发者需要自行实现相应的算法和逻辑来实现虚拟滚动效果。